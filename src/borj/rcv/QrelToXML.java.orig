package borj.rcv;

import boxer.*;

import java.util.*;
import java.io.*;

/** Prepares XML files with labels, taken from the QREL files. These
    later can be combined with the feature-only XML files produced by
    RcvToXML

    Usage: 
<pre>
 java [-Dd=/home/rcv] [-Dout=/home/vmenkov/rcv-out] [-Dfrom=1] [-Dto=100] borj.rcv.Driver docids.txt
</pre>

    The output XML file will be deposited in the directory specified
    by the "out" option; its name will be based on the name of the
    input doc ID file, and the "from" and "to" values (if any).

 */
public class QrelToXML {

    static void usage() {
	usage(null);
    }

    static void usage(String m) {
	System.out.println("Usage: java [-Dd=/home/rcv] [-Dout=/home/vmenkov/rcv-out] [-Dfrom=1] [-Dto=100] borj.rcv.Driver docids.txt");
	if (m!=null) {
	    System.out.println(m);
	}
	System.exit(1);
    }
    
    static public void main(String argv[]) throws IOException, org.xml.sax.SAXException{

	//memory();

	ParseConfig ht = new ParseConfig();
	/** The directory where the original rv files are */
	String d = "/home/vmenkov/rcv";
	d =ht.getOption("d", d);
	String outdir = ht.getOption("out", "/home/vmenkov/borj.rcv-out");

	int from = ht.getOption("from", 0),  to = ht.getOption("to", 0);

	if (argv.length != 1) usage();
	String idFile = argv[0];
	System.out.println("Reading doc IDs from " + idFile + 
			   (from == 0? " beginning" : " line " + from) + " to"+
			   (to == 0? " end" : " line " + to) );

	int a[] = RcvUtil.readIds(idFile, from, to);
	IntSet docids = new IntSet(a);

	Suite suite = new Suite();

	/*
BOXER_Small_Topics
     Training Set: Prefixes starting at RandIDa 000001
     Test Set: Last 1000 RandIDa
     Categories: The 10 most frequent Topic categories, treated as 10 binary discriminations

BOXER_Small_Industries
     Training Set: Prefixes starting at RandIDa 000001
     Test Set: Last 1000 RandIDa
     Categories: A 10-way polytomous classification.  The categories should be NoIndustry, the 8 most frequent original Industry categories, and Other where Other corresponds to any other Industry category.

BOXER_Small_Regions
     Training Set: Prefixes starting at RandIDa 000001
     Test Set: Last 1000 RandIDa
     Categories: A 10-way polytomous classification.  The categories should be the 9 most frequent Region categories, and Other where Other corresponds to any other Region category.
	*/
	

	String ftop = d + File.separator + "rcv1-v2.topics.qrels";
	int ntop = 10;
	SiPair[] topTopics = topCat( null /*docids*/,  ftop, ntop);
	System.out.println("Top " + topTopics.length + " topics:");
	for(int i=0; i<topTopics.length; i++) {
	    System.out.println("(" + i +") "  + topTopics[i].cat + ": " + 
			       topTopics[i].cnt + " docs");

	    String disName = RcvToXML.TOPIC+ "_" + topTopics[i].cat;
	    suite.getClaAlways(disName, topTopics[i].cat, Suite.ND.ADD, Suite.NC.ADD);
	    suite.getClaAlways(disName, "other",  Suite.ND.ADD, Suite.NC.ADD).makeDefault();
	}


	String find = d + File.separator + "rcv1-v2.industries.qrels";
	SiPair[] topInd = topCat( null,  find, ntop=8);
	System.out.println("Top " + topInd.length + " industries:");

	String disName =  RcvToXML.INDUSTRY;
	for(int i=0; i<topInd.length; i++) {
	    System.out.println("(" + i +") "  + topInd[i].cat + ": " + 
			       topInd[i].cnt + " docs");

	    suite.getClaAlways(disName, topInd[i].cat,  Suite.ND.ADD, Suite.NC.ADD);
	}
	suite.getClaAlways(disName, "other", Suite.ND.ADD,  Suite.NC.ADD);
	suite.getClaAlways(disName, "none", Suite.ND.ADD, Suite.NC.ADD).makeDefault();
	
	String freg = d + File.separator + "rcv1-v2.regions.qrels";
	SiPair[] topReg = topCat( null,  freg, ntop=9);
	System.out.println("Top " + topReg.length + " regions:");
	disName = RcvToXML.REGION;
	for(int i=0; i<topReg.length; i++) {
	    System.out.println("(" + i +") "  + topReg[i].cat + ": " + 
			       topReg[i].cnt + " docs");

	    suite.getClaAlways(disName, topReg[i].cat, Suite.ND.ADD, Suite.NC.ADD);
	}
	suite.getClaAlways(disName, RcvToXML.OTHER,  Suite.ND.ADD, Suite.NC.ADD).makeDefault();

	suite.saveAsXML(outdir + File.separator +"rcv-small-cat-suite.xml");

	// now, convert QREL to XML
	FeatureDictionary dic = new FeatureDictionary();
	HashMap<Integer, DataPoint> docs = new HashMap<Integer, DataPoint>();
	Vector <DataPoint.FVPair> empty = new 	Vector <DataPoint.FVPair>();
	for(int docid: a) {
	    docs.put(new Integer(docid), new DataPoint(empty,dic,""+docid));
	}
	
	readQrelToPoly(docs, freg, RcvToXML.REGION, RcvToXML.OTHER, suite);
	readQrelToPoly(docs, find, RcvToXML.INDUSTRY, RcvToXML.OTHER, suite);
	readQrelToBinary(docs, ftop,  RcvToXML.TOPIC,  suite);

	Vector<DataPoint> v = RcvToXML.setToVector(a,docs,suite, false);
	String setName = RcvToXML.fnameToSetname(idFile, from, to);
	String outqrel = outdir + File.separator + setName+ "-qrel.xml";
	System.out.println("Writing data set " + setName + " with " + v.size() +
			   " documents to file " + outqrel);
	DataPoint.saveAsXML( v, setName, outqrel);


    }

   /** Reads a QREL file, adding classes to the documents that appear
     * in the map.   */
    static void readQrelToBinary(HashMap<Integer,DataPoint> docs, String fname, 
			 String disPrefix, Suite suite)  throws IOException
    {
	for(QrelIterator it = new QrelIterator(fname); it.hasNext(); ) {
	    QrelEntry q= it.next();
	    Integer key=new Integer(q.docid);

	    DataPoint doc = docs.get(key);
	    if (doc == null) continue;

	    String disName = disPrefix + "_" + q.cat;
	    Discrimination.Cla cla = suite.getCla(disName, q.cat);
	    // on duplication, report an error
	    if (cla!=null) doc.addClass(cla, suite, false); 
	}
    }

    /** Puts in the classes already listed in the Suite, or "other" 	
	@param replaceName If this parameter is not null, classes absent from the current suite will be replaced with the class of this name. A class of this name must already exist in the suite,
     */
    static void readQrelToPoly(HashMap<Integer,DataPoint> docs, String fname, 
			       String disName, String replaceName, Suite suite)  throws IOException
    {
	for(QrelIterator it = new QrelIterator(fname); it.hasNext(); ) {
	    QrelEntry q= it.next();
	    Integer key=new Integer(q.docid);

	    DataPoint doc = docs.get(key);
	    if (doc == null) continue;

	    Discrimination.Cla cla=suite.getCla(disName, q.cat);
	    if (cla==null && replaceName != null) {
		cla=suite.getCla(disName, replaceName);
		if (cla==null) throw new AssertionError("Class '" + q.cat + "' or '" + replaceName + "' should be listed in disc " + disName + " already!");
	    }
	    // on duplication, report an error
	    if (cla!=null)  doc.addClass(cla, suite, false); 
	}
    }


    /** More efficient for fairly dense sets than HashSet<Integer> */
    static class IntSet {
	BitSet b;
	/** Creates a set that will be able hold elements with values
	 * from 0 thru n-1 */
	IntSet(int n) { b = new BitSet(n); }
	void add(int x) { b.set(x); }
	boolean contains(int x) { return b.get(x); }
	IntSet(int a[]) {
	    b = new BitSet();
	    for(int x : a) b.set(x);
	}
    }

    /** Reads a QREL file
       @return A lits of (docidCnt) pairs
	*/
    /*(
    static  PairList  readQREL(String fname)	throws IOException    {
	PairList v = new PairList();
	int cnt=0;
	for(QrelIterator it = new QrelIterator(fname); it.hasNext(); ) {
	    QrelEntry q = it.next();
	    cnt++;
	    if (v.size() == 0 || 
		v.lastElement().id < q.docid) {
		v.add( new Pair(q.docid, 1));
	    } else if (v.lastElement().id == q.docid) {
		v.lastElement().incCatCnt();
	    } else {
		throw new IllegalArgumentException("Doc id " + q.docid + " out of order");
	    }
	}
	System.out.println("Line count=" + cnt);
	return v;
    }
    */
   
    /** Returns a set of all categories that occur in the QREL file
     *  in association with document ids from a specified set
     @param fname QREL File to read
     @docs List of doc ids. The function only looks at the lines in the QREL file where the doc id is in this list
     */

    static HashSet<String> listCat(IntSet docs, String fname)
	throws IOException
    {
	HashSet<String> cats = new HashSet<String>();
	for(QrelIterator it = new QrelIterator(fname); it.hasNext(); ) {
	    QrelEntry q = it.next();
	    if (docs.contains(new Integer(q.docid))) cats.add(q.cat); 
	}
	return cats;
    }

    /** Returns a HashMap that maps category name to the number of docs
	from the specified set that have that category assigned to it in the
	QREL file
	@param docs The set of documents we want to look at. If null, look at all docs in the Qrel file
    */
    static HashMap<String, Integer> listCatCnt(IntSet docs, String fname)
	throws IOException
    {
	HashMap<String, Integer> cats = new HashMap<String,Integer>();
	for(QrelIterator it = new QrelIterator(fname); it.hasNext(); ) {
	    QrelEntry q = it.next();
	    if (docs==null || docs.contains(new Integer(q.docid))) {
		Integer z = cats.get(q.cat);
		int cnt = (z==null) ? 0 : z.intValue();
		cats.put( q.cat, new Integer(cnt+1));
	    }
	}
	return cats;
    }

    private static class SiPair implements Comparable {
	String cat;
	int cnt;
	SiPair(Map.Entry<String,Integer> x) {
	    cat = x.getKey();
	    cnt = x.getValue().intValue();
	}
	/** For reverse (descending) order */
	public int compareTo(Object o) throws ClassCastException  {
	    //if (!o instanceof SiPair) throw new  ClassCastException(o.toString());
	    return ((SiPair)o).cnt - cnt;
	}
    }

    /** Gets most populated categories
	@param docs The set of documents we want to look at. If null, look at all docs in the Qrel file
     */
    static SiPair[] topCat(IntSet docs, String fname, int ntop) throws IOException {
	HashMap<String, Integer> h = listCatCnt( docs, fname);
	int n = h.size();
	SiPair a[] = new SiPair[n];
	int pos=0;
	for( Map.Entry<String,Integer> x: h.entrySet() ) {
	    a[pos++] = new SiPair(x);
	}
	Arrays.sort(a);
	return (ntop<n) ? Arrays.copyOf(a, ntop) : a;
    }

}	

